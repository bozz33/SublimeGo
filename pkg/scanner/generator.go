package scanner

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"text/template"
	"time"
)

// Generator generates the provider_gen.go file with Wire Pattern.
type Generator struct {
	config ScannerConfig
}

// NewGenerator creates a new generator with default configuration.
func NewGenerator(outputPath string) *Generator {
	config := DefaultConfig()
	config.OutputPath = outputPath
	return &Generator{
		config: config,
	}
}

// NewGeneratorWithConfig creates a new generator with custom configuration.
func NewGeneratorWithConfig(config ScannerConfig) *Generator {
	return &Generator{
		config: config,
	}
}

// Generate generates the provider_gen.go file with Wire Pattern.
func (g *Generator) Generate(result ScanResult) GenerationResult {
	start := time.Now()

	if len(result.Resources) == 0 {
		return GenerationResult{
			Success:  false,
			Message:  "no resources found to generate",
			Duration: time.Since(start),
		}
	}

	detector := NewDetector(result.Resources)
	if detector.HasErrors(result.Conflicts) && !g.config.AutoFix {
		return GenerationResult{
			Success:   false,
			Message:   "blocking conflicts detected and auto-fix disabled",
			Conflicts: result.Conflicts,
			Duration:  time.Since(start),
		}
	}

	scanner := NewWithConfig(g.config)
	templateData := scanner.BuildTemplateData(result)

	if g.config.Verbose && len(templateData.Warnings) > 0 {
		fmt.Println("Warnings detected:")
		for _, warning := range templateData.Warnings {
			fmt.Printf("   - %s\n", warning)
		}
	}

	if g.config.Verbose && len(templateData.Conflicts) > 0 {
		fmt.Println("Conflicts detected:")
		for _, conflict := range templateData.Conflicts {
			fmt.Printf("   - [%s] %s\n", conflict.Severity, conflict.Message)
			if conflict.AutoFix {
				fmt.Printf("     Auto-fix: %s\n", conflict.Suggestion)
			}
		}
	}

	if g.config.DryRun {
		return GenerationResult{
			Success:   true,
			Message:   "dry-run: would generate code",
			Warnings:  templateData.Warnings,
			Conflicts: templateData.Conflicts,
			Duration:  time.Since(start),
		}
	}

	code, err := g.generateCode(templateData)
	if err != nil {
		return GenerationResult{
			Success:  false,
			Message:  fmt.Sprintf("failed to generate code: %v", err),
			Duration: time.Since(start),
		}
	}

	formatted, err := format.Source([]byte(code))
	if err != nil {
		return GenerationResult{
			Success:  false,
			Message:  fmt.Sprintf("failed to format code: %v", err),
			Duration: time.Since(start),
		}
	}

	dir := filepath.Dir(g.config.OutputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return GenerationResult{
			Success:  false,
			Message:  fmt.Sprintf("failed to create directory: %v", err),
			Duration: time.Since(start),
		}
	}

	bytesWritten := len(formatted)
	if err := os.WriteFile(g.config.OutputPath, formatted, 0644); err != nil {
		return GenerationResult{
			Success:  false,
			Message:  fmt.Sprintf("failed to write file: %v", err),
			Duration: time.Since(start),
		}
	}

	message := fmt.Sprintf("generated %s (%d bytes, %d resources)",
		g.config.OutputPath, bytesWritten, len(result.Resources))
	if len(templateData.Warnings) > 0 {
		message += fmt.Sprintf(" with %d warnings", len(templateData.Warnings))
	}
	if len(templateData.Conflicts) > 0 {
		message += fmt.Sprintf(" (%d conflicts resolved)", len(templateData.Conflicts))
	}

	return GenerationResult{
		FilePath:     g.config.OutputPath,
		BytesWritten: bytesWritten,
		Success:      true,
		Message:      message,
		Warnings:     templateData.Warnings,
		Conflicts:    templateData.Conflicts,
		Duration:     time.Since(start),
	}
}

// providerTemplate contains the embedded template if the template file doesn't exist.
const providerTemplate = `// Code generated by SublimeGo Scanner. DO NOT EDIT.
// Generated at: {{.Timestamp}}
// Resources found: {{.Count}}

package registry

import (
{{range .Imports}}
	{{if .NeedsAlias}}{{.Alias}} {{end}}"{{.Path}}"
{{end}}
	"github.com/bozz33/SublimeGo/pkg/engine"
)

{{if .Warnings}}
// WARNINGS:
{{range .Warnings}}
//     {{.}}
{{end}}
{{end}}

{{if .Conflicts}}
// CONFLICTS DETECTED:
{{range .Conflicts}}
//     {{.Type}}: {{.Message}}
//     Suggestion: {{.Suggestion}}
//     Auto-fix: {{if .AutoFix}}Available{{else}}Not available{{end}}
{{end}}
{{end}}

// AllResources contains all discovered resources.
var AllResources = []engine.Resource{
{{range .Resources}}
	&{{.Reference}}{}, // {{.Source}}{{if .Conflict}} (conflict resolved with alias){{end}}
{{end}}
}

// ResourceCount returns the number of registered resources.
func ResourceCount() int {
	return {{.Count}}
}

// GetResourceBySlug returns a resource by its slug.
func GetResourceBySlug(slug string) (engine.Resource, bool) {
	for _, resource := range AllResources {
		if resource.Slug() == slug {
			return resource, true
		}
	}
	return nil, false
}

// HasResource checks if a resource with the given slug exists.
func HasResource(slug string) bool {
	_, exists := GetResourceBySlug(slug)
	return exists
}

// GetAllSlugs returns all resource slugs.
func GetAllSlugs() []string {
	slugs := make([]string, 0, len(AllResources))
	for _, resource := range AllResources {
		slugs = append(slugs, resource.Slug())
	}
	return slugs
}

// ResourceInfo contains metadata about a resource.
type ResourceInfo struct {
	Slug        string
	Label       string
	PluralLabel string
	Icon        string
}

// GetResourceInfo returns metadata for all resources.
func GetResourceInfo() []ResourceInfo {
	info := make([]ResourceInfo, 0, len(AllResources))
	for _, resource := range AllResources {
		info = append(info, ResourceInfo{
			Slug:        resource.Slug(),
			Label:       resource.Label(),
			PluralLabel: resource.PluralLabel(),
			Icon:        resource.Icon(),
		})
	}
	return info
}

{{if .Conflicts}}
// ConflictInfo contains information about detected conflicts.
type ConflictInfo struct {
	Type       string
	Severity   string
	Message    string
	Suggestion string
	AutoFix    bool
}

// GetConflicts returns all detected conflicts.
func GetConflicts() []ConflictInfo {
	return []ConflictInfo{
{{range .Conflicts}}
		{
			Type:       "{{.Type}}",
			Severity:   "{{.Severity}}",
			Message:    "{{.Message}}",
			Suggestion: "{{.Suggestion}}",
			AutoFix:    {{.AutoFix}},
		},
{{end}}
	}
}
{{end}}

// RegistryStats contains statistics about the registry.
type RegistryStats struct {
	TotalResources int
	TotalConflicts int
	TotalWarnings  int
	GeneratedAt    string
}

// GetStats returns registry statistics.
func GetStats() RegistryStats {
	return RegistryStats{
		TotalResources: {{.Count}},
		TotalConflicts: {{len .Conflicts}},
		TotalWarnings:  {{len .Warnings}},
		GeneratedAt:    "{{.Generated.Format "2006-01-02 15:04:05"}}",
	}
}
`

// generateCode generates code from the Wire Pattern template.
func (g *Generator) generateCode(data TemplateData) (string, error) {
	templatePath := filepath.Join(filepath.Dir(g.config.OutputPath), "..", "..", "internal", "scanner", "templates", "provider.go.tmpl")

	if _, err := os.Stat(templatePath); os.IsNotExist(err) {
		tmpl := template.Must(template.New("provider").Parse(providerTemplate))

		var buf bytes.Buffer
		if err := tmpl.Execute(&buf, data); err != nil {
			return "", err
		}

		return buf.String(), nil
	}

	templateContent, err := os.ReadFile(templatePath)
	if err != nil {
		return "", fmt.Errorf("failed to read template: %w", err)
	}

	tmpl := template.Must(template.New("provider").Parse(string(templateContent)))

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}
